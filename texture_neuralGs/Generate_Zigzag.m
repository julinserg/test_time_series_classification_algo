function [Indices, Indices_l] = Generate_Zigzag(N)
% Генерация индексов для обхода матрицы по зигзагу
%     Входные параметры:
%                        N - количество элементов в квадратной матрице
%     Выходные параметры:
%                        Indices - массив (N^2,2), содержащий номера строк
%                        и столбцов элементов квадратной матрица в порядке
%                        обхода. Первый столбец соответствует номеру строки,
%                        второй столбец - номера столбца
%                        Indices_l - массив (N^2,1), содержащий ту же самую
%                        информацию, что и Indices, но номера элементов
%                        приведены в виде одномерного смещения от начала
%                        массива. При этом учитывается, что матрица в MATLAB
%                        хранится по столбцам!
%--------------------------------------------------------------------------

Indices = zeros(N*N, 2); % заранее выделяем место под матрицу (N^2 x 2)
    % Первую диагонально проходим вручную (один элемент)
Indices(1, :) = [1 1];
a = 2;                     % сдвигаем индекс в таблице индексов
       % обрабатываем диагонали длиной больше 1 (все, кроме первой и последней)
for t=2:1:(2*N-2)          % В матрице NxN строк есть 2N-1 диагоналей. Одну уже прошли
       % сначала отрабатываем переход на первый элемент диагонали
       % и устаналиваем необходимые параметры движения по ней
    if (rem(t,2)~=0)         % если диагональ нечетная (rem – остаток от деления)
        dr = 1; dc = -1;     % приращения для перехода к следующему элементу диагонали
        if (t <= N)          % длина диагонали растет или уменьшается?
            P = t;           % если растет - то число элементов равно номеру диагонали
            Indices(a, 1) = Indices(a-1, 1);
            Indices(a, 2) = Indices(a-1, 2)+1;
        else
            P = 2*N-t;       % иначе: (2N - номер диагонали)
            Indices(a, 1) = Indices(a-1, 1)+1;
                                                                                         47


              Indices(a, 2) = Indices(a-1, 2);
          end
      else                    % если диагональ четная
          dr = -1; dc = 1;
          if (t <= N)         % длина диагонали растет или уменьшается?
              P = t;          % если растет - то число элементов равно номеру диагонали
              Indices(a, 1) = Indices(a-1, 1) + 1;
              Indices(a, 2) = Indices(a-1, 2);
          else
              P = 2*N-t;      % иначе: (2N - номер диагонали)
              Indices(a, 1) = Indices(a-1, 1);
              Indices(a, 2) = Indices(a-1, 2)+1;
          end
      end
      a = a + 1;              % первый элемент диагонали обработали
          % теперь проходим по оставшимся элементам диагонали
      for i=2:1:P
          Indices(a, 1) = Indices(a-1, 1) + dr;
          Indices(a, 2) = Indices(a-1, 2) + dc;
          a = a + 1;
      end
end
    % Последнюю диагонально проходим вручную (один элемент)
Indices(N*N, :) = [N N];
    % Дополнительно расчитывает линейные индексы элементов
    % Для преобразования (row,col) => ind может использоваться
    % функция sub2ind вида
    % ix = sub2ind([n n], ind(:,1), ind(:,2));
    % Но поскольку она очень "медленная", то вместо нее
    % лучше рассчитывать смещение от начала матрицы "вручную". При этом
    % следует помнить, что в MATLAB двумерный массив хранится по столбцам.
Indices_l = (Indices(:,2)-1)*N + Indices(:,1);